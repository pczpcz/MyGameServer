name: Deploy to Dev

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: docker.io
  IMAGE_NAME: ${{ secrets.DOCKERHUB_USERNAME }}/${{ github.event.repository.name }}

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Clean Docker cache
      run: |
        docker system prune -f
        docker builder prune -f -a

    - name: Build and push backend image
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        file: ./backend/Dockerfile
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:${{ github.sha }}
        # 完全禁用缓存
        no-cache: true
        # 强制重新构建所有层
        build-args: |
          BUILD_DATE=${{ github.event.head_commit.timestamp }}
          COMMIT_SHA=${{ github.sha }}

    - name: Build and push frontend image
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        file: ./frontend/Dockerfile
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:${{ github.sha }}
        # 完全禁用缓存
        no-cache: true
        # 强制重新构建所有层
        build-args: |
          BUILD_DATE=${{ github.event.head_commit.timestamp }}
          COMMIT_SHA=${{ github.sha }}

  deploy:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install SSH Key
      uses: webfactory/ssh-agent@v0.5.3
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: Deploy to server
      run: |
        echo "Deployment would happen here"
        echo "Images built and pushed successfully:"
        echo "- ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:${{ github.sha }}"
        echo "- ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:${{ github.sha }}"
        echo "MySQL and Nginx configs available for deployment"
        
        # 检查文件是否存在
        ls -la mysql/init.sql
        ls -la nginx/nginx.prod.conf
        ls -la docker-compose.prod.yml
        ls -la scripts/setup-ssl.sh
        
        # 上传所有必要的文件到服务器
        scp -o StrictHostKeyChecking=no mysql/init.sql ${{ secrets.EC2_USER }}@${{ secrets.EC2_INSTANCE_IP }}:/tmp/init.sql
        scp -o StrictHostKeyChecking=no nginx/nginx.prod.conf ${{ secrets.EC2_USER }}@${{ secrets.EC2_INSTANCE_IP }}:/tmp/nginx.prod.conf
        scp -o StrictHostKeyChecking=no docker-compose.prod.yml ${{ secrets.EC2_USER }}@${{ secrets.EC2_INSTANCE_IP }}:/tmp/docker-compose.prod.yml
        scp -o StrictHostKeyChecking=no scripts/setup-ssl.sh ${{ secrets.EC2_USER }}@${{ secrets.EC2_INSTANCE_IP }}:/tmp/setup-ssl.sh
        
        # SSH部署到EC2示例
        ssh -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@${{ secrets.EC2_INSTANCE_IP }} << 'EOF'
        # 确保必要的目录存在
        mkdir -p /tmp mysql nginx scripts
        
        # 停止并删除所有运行的容器
        RUNNING_CONTAINERS=$(sudo docker ps -q)
        if [ ! -z "$RUNNING_CONTAINERS" ]; then
          sudo docker stop $RUNNING_CONTAINERS
          sudo docker rm $RUNNING_CONTAINERS
        fi
        
        # 删除所有未运行的容器
        ALL_CONTAINERS=$(sudo docker ps -a -q)
        if [ ! -z "$ALL_CONTAINERS" ]; then
          sudo docker rm $ALL_CONTAINERS
        fi
        
        # 删除所有Docker镜像（包括未使用的和正在使用的）
        ALL_IMAGES=$(sudo docker images -q)
        if [ ! -z "$ALL_IMAGES" ]; then
          sudo docker rmi -f $ALL_IMAGES
        fi
        
        # 清理Docker系统（卷、网络等）
        sudo docker system prune -a -f --volumes
        
        # 使用sudo拉取最新镜像（解决Docker权限问题）
        # 使用唯一标签确保拉取最新版本
        sudo docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:${{ github.sha }}
        sudo docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:${{ github.sha }}
        sudo docker pull nginx:alpine
        sudo docker pull mysql:8.0
        
        # 确保配置文件和初始化脚本在正确位置
        mv /tmp/init.sql mysql/init.sql
        # 将nginx.prod.conf覆盖nginx.conf，确保Nginx使用正确配置
        mv /tmp/nginx.prod.conf nginx/nginx.prod.conf
        mv /tmp/docker-compose.prod.yml docker-compose.prod.yml
        mv /tmp/setup-ssl.sh scripts/setup-ssl.sh
        chmod +x scripts/setup-ssl.sh
        
        # 创建.env文件来设置环境变量（docker-compose会自动读取）
        echo "DOCKERHUB_USERNAME=${{ secrets.DOCKERHUB_USERNAME }}" > .env
        echo "REPOSITORY_NAME=${{ github.event.repository.name }}" >> .env
        echo "COMMIT_SHA=${{ github.sha }}" >> .env
        
        # 使用生产环境的docker-compose文件启动服务（需要sudo权限）
        # 如果docker-compose命令不存在，使用docker compose替代
        if command -v docker-compose &> /dev/null; then
          sudo docker-compose -f docker-compose.prod.yml up -d
        else
          sudo docker compose -f docker-compose.prod.yml up -d
        fi
        
        # 等待nginx容器启动
        echo "等待nginx容器启动..."
        sleep 10
        
        # 使用docker cp方法确保nginx配置正确应用
        NGINX_CONTAINER=$(sudo docker ps --filter "name=nginx_proxy" --format "{{.ID}}")
        if [ ! -z "$NGINX_CONTAINER" ]; then
          echo "找到nginx容器: $NGINX_CONTAINER"
          
          # 复制nginx配置到容器
          sudo cp nginx/nginx.prod.conf nginx/nginx.conf
          sudo docker cp nginx/nginx.conf $NGINX_CONTAINER:/etc/nginx/nginx.conf
          
          # 测试nginx配置
          sudo docker exec $NGINX_CONTAINER nginx -t
          
          # 重新加载nginx配置
          sudo docker exec $NGINX_CONTAINER nginx -s reload
          
          echo "nginx配置已通过docker cp方法更新并重新加载"
        else
          echo "警告: 未找到nginx容器"
        fi
        
        # 验证服务状态
        echo "验证服务状态..."
        sudo docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
        
        # 再次清理未使用的镜像和容器
        sudo docker system prune -f
        EOF
