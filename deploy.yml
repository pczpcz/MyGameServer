name: Deploy to Dev

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: docker.io
  IMAGE_NAME: ${{ secrets.DOCKERHUB_USERNAME }}/${{ github.event.repository.name }}

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Build and push backend image
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        file: ./backend/Dockerfile
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build and push frontend image
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        file: ./frontend/Dockerfile
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max


  deploy:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4


    - name: Install SSH Key
      uses: webfactory/ssh-agent@v0.5.3
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: Deploy to server
      run: |
        echo "Deployment would happen here"
        echo "Images built and pushed successfully:"
        echo "- ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:latest"
        echo "- ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:latest"
        echo "MySQL and Nginx configs available for deployment"
        
        # 检查文件是否存在
        ls -la mysql/init.sql
        ls -la nginx/nginx.prod.conf
        ls -la docker-compose.prod.yml
        
        # 上传所有必要的文件到服务器
        scp -o StrictHostKeyChecking=no mysql/init.sql ${{ secrets.EC2_USER }}@${{ secrets.EC2_INSTANCE_IP }}:/tmp/init.sql
        scp -o StrictHostKeyChecking=no nginx/nginx.prod.conf ${{ secrets.EC2_USER }}@${{ secrets.EC2_INSTANCE_IP }}:/tmp/nginx.prod.conf
        scp -o StrictHostKeyChecking=no docker-compose.prod.yml ${{ secrets.EC2_USER }}@${{ secrets.EC2_INSTANCE_IP }}:/tmp/docker-compose.prod.yml
        
        # SSH部署到EC2示例
        ssh -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@${{ secrets.EC2_INSTANCE_IP }} << 'EOF'
        # 确保必要的目录存在
        mkdir -p /tmp mysql nginx
        
        # 停止并删除当前运行的容器
        RUNNING_CONTAINERS=$(sudo docker ps -q)
        if [ ! -z "$RUNNING_CONTAINERS" ]; then
          sudo docker stop $RUNNING_CONTAINERS
          sudo docker rm $RUNNING_CONTAINERS
        fi
        
        # 清理旧的Docker镜像以节省空间
        sudo docker image prune -f
        
        # 使用sudo拉取最新镜像（解决Docker权限问题）
        # 只拉取需要的镜像，避免重复下载
        sudo docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:latest
        sudo docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:latest
        sudo docker pull nginx:alpine
        sudo docker pull mysql:8.0
        
        # 删除旧的镜像版本（保留最新版本）
        sudo docker images --filter "dangling=true" -q | xargs -r sudo docker rmi
        
        # 确保配置文件和初始化脚本在正确位置
        mv /tmp/init.sql mysql/init.sql
        mv /tmp/nginx.prod.conf nginx/nginx.prod.conf
        mv /tmp/docker-compose.prod.yml docker-compose.prod.yml
        
        # 创建.env文件来设置环境变量（docker-compose会自动读取）
        echo "DOCKERHUB_USERNAME=${{ secrets.DOCKERHUB_USERNAME }}" > .env
        echo "REPOSITORY_NAME=${{ github.event.repository.name }}" >> .env
        
        # 使用生产环境的docker-compose文件启动服务（需要sudo权限）
        # 如果docker-compose命令不存在，使用docker compose替代
        if command -v docker-compose &> /dev/null; then
          sudo docker-compose -f docker-compose.prod.yml up -d
        else
          sudo docker compose -f docker-compose.prod.yml up -d
        fi
        
        # 再次清理未使用的镜像和容器
        sudo docker system prune -f
        EOF
